<?xml version="1.0" encoding="utf-8"?>
<helpItems xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" schema="maml" xmlns="http://msh">
  <command:command>
    <command:details>
      <command:name>Get-PSReadLineKeyHandler</command:name>
      <maml:description>
        <maml:para>Gets the key bindings for the PSReadLine module.</maml:para>
      </maml:description>
      <command:verb>Get</command:verb>
      <command:noun>PSReadLineKeyHandler</command:noun>
    </command:details>
    <maml:description>
      <maml:para>If no parameter is specified, returns the currently bound key functions for the PSReadLine module.</maml:para>
      <maml:para>If **Chord** parameter is specified, the cmdlet returns the specific bound keys.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Get-PSReadLineKeyHandler</maml:name>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Get-PSReadLineKeyHandler</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="0" aliases="none">
          <maml:name>Chord</maml:name>
          <maml:description>
            <maml:para>Return only functions bound to specific keys or sequences.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">System.String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>Bound</maml:name>
        <maml:description>
          <maml:para>Indicates that this cmdlet returns functions that are bound.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="0" aliases="none">
        <maml:name>Chord</maml:name>
        <maml:description>
          <maml:para>Return only functions bound to specific keys or sequences.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">System.String[]</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>Unbound</maml:name>
        <maml:description>
          <maml:para>Indicates that this cmdlet returns functions that are unbound.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>You can't pipe objects to this cmdlet.</maml:para>
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <dev:name>Microsoft.PowerShell.KeyHandler</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>This cmdlet returns a **KeyHandler** object.</maml:para>
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <maml:alertSet>
      <maml:alert>
        <maml:para />
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>--------- Example 1: Get all key mappings ---------</maml:title>
        <maml:introduction>
          <maml:para>This command returns all key mappings, bound and unbound.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Get-PSReadLineKeyHandler -Bound -Unbound
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```Output
Key                   Function                Description
---                   --------                -----------
Enter                 AcceptLine              Accept the input or move to the next line if input is missing a closing token.
Shift+Enter           AddLine                 Move the cursor to the next line without attempting to execute the input
Escape                RevertLine              Equivalent to undo all edits (clears the line except lines imported from history)
LeftArrow             BackwardChar            Move the cursor back one character
RightArrow            ForwardChar             Move the cursor forward one character
Ctrl+LeftArrow        BackwardWord            Move the cursor to the beginning of the current or previous word
Ctrl+RightArrow       NextWord                Move the cursor forward to the start of the next word
Shift+LeftArrow       SelectBackwardChar      Adjust the current selection to include the previous character
Shift+RightArrow      SelectForwardChar       Adjust the current selection to include the next character
Ctrl+Shift+LeftArrow  SelectBackwardWord      Adjust the current selection to include the previous word
Ctrl+Shift+RightArrow SelectNextWord          Adjust the current selection to include the next word
UpArrow               PreviousHistory         Replace the input with the previous item in the history
DownArrow             NextHistory             Replace the input with the next item in the history
Home                  BeginningOfLine         Move the cursor to the beginning of the line
End                   EndOfLine               Move the cursor to the end of the line
Shift+Home            SelectBackwardsLine     Adjust the current selection to include from the cursor to the end of the line
Shift+End             SelectLine              Adjust the current selection to include from the cursor to the start of the line
Delete                DeleteChar              Delete the character under the cursor
Backspace             BackwardDeleteChar      Delete the character before the cursor
Ctrl+Spacebar         MenuComplete            Complete the input if there is a single completion, otherwise complete the input by selecting from a menu o...
Tab                   TabCompleteNext         Complete the input using the next completion
Shift+Tab             TabCompletePrevious     Complete the input using the previous completion
Ctrl+a                SelectAll               Select the entire line. Moves the cursor to the end of the line
Ctrl+c                CopyOrCancelLine        Either copy selected text to the clipboard, or if no text is selected, cancel editing the line with Cancel...
Ctrl+C                Copy                    Copy selected region to the system clipboard.  If no region is selected, copy the whole line
Ctrl+l                ClearScreen             Clear the screen and redraw the current line at the top of the screen
Ctrl+r                ReverseSearchHistory    Search history backwards interactively
...
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 2: Get bound keys ---------</maml:title>
        <maml:introduction>
          <maml:para>This command returns only bound keys and key combinations.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Get-PSReadLineKeyHandler
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```Output
Key                   Function                Description
---                   --------                -----------
Enter                 AcceptLine              Accept the input or move to the next line if input is missing a closing token.
Shift+Enter           AddLine                 Move the cursor to the next line without attempting to execute the input
Escape                RevertLine              Equivalent to undo all edits (clears the line except lines imported from history)
LeftArrow             BackwardChar            Move the cursor back one character
RightArrow            ForwardChar             Move the cursor forward one character
Ctrl+LeftArrow        BackwardWord            Move the cursor to the beginning of the current or previous word
Ctrl+RightArrow       NextWord                Move the cursor forward to the start of the next word
Shift+LeftArrow       SelectBackwardChar      Adjust the current selection to include the previous character
Shift+RightArrow      SelectForwardChar       Adjust the current selection to include the next character
Ctrl+Shift+LeftArrow  SelectBackwardWord      Adjust the current selection to include the previous word
Ctrl+Shift+RightArrow SelectNextWord          Adjust the current selection to include the next word
UpArrow               PreviousHistory         Replace the input with the previous item in the history
DownArrow             NextHistory             Replace the input with the next item in the history
Home                  BeginningOfLine         Move the cursor to the beginning of the line
End                   EndOfLine               Move the cursor to the end of the line
Shift+Home            SelectBackwardsLine     Adjust the current selection to include from the cursor to the end of the line
Shift+End             SelectLine              Adjust the current selection to include from the cursor to the start of the line
Delete                DeleteChar              Delete the character under the cursor
Backspace             BackwardDeleteChar      Delete the character before the cursor
Ctrl+Spacebar         MenuComplete            Complete the input if there is a single completion, otherwise complete the input by selecting from a menu o...
Tab                   TabCompleteNext         Complete the input using the next completion
...
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 3: Get specific key bindings ---------</maml:title>
        <maml:introduction>
          <maml:para>This command returns only the bindings for the specified keys.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Get-PSReadLineKeyHandler -Chord Enter, Shift+Enter
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```Output
Key         Function   Description
---         --------   -----------
Enter       AcceptLine Accept the input or move to the next line if input is missing a closing token.
Shift+Enter AddLine    Move the cursor to the next line without attempting to execute the input
...
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
    </command:examples>
    <command:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Online Version</maml:linkText>
        <command:uri>https://learn.microsoft.com/powershell/module/psreadline/get-psreadlinekeyhandler?view=powershell-7.5&amp;WT.mc_id=ps-gethelp</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Remove-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Remove-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineOption</maml:linkText>
        <command:uri>Get-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineOption</maml:linkText>
        <command:uri>Set-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Set-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
    </command:relatedLinks>
  </command:command>
  <command:command>
    <command:details>
      <command:name>Get-PSReadLineOption</command:name>
      <maml:description>
        <maml:para>Gets values for the options that can be configured.</maml:para>
      </maml:description>
      <command:verb>Get</command:verb>
      <command:noun>PSReadLineOption</command:noun>
    </command:details>
    <maml:description>
      <maml:para>The `Get-PSReadLineOption` cmdlet returns the current state of the settings that can be configured using the `Set-PSReadLineOption` cmdlet. You can use the returned object to change **PSReadLine** options. This provides a slightly simpler way to set syntax coloring options for multiple kinds of tokens.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Get-PSReadLineOption</maml:name>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters />
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>You can't pipe objects to this cmdlet.</maml:para>
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <dev:name>Microsoft.PowerShell.PSConsoleReadLineOptions</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>This cmdlet returns an instance of the current options. Changing the property values of this object
updates the settings in PSReadLine directly without invoking `Set-PSReadLineOption`.</maml:para>
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <maml:alertSet>
      <maml:alert>
        <maml:para />
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>--------- Example 1: Get options and their values ---------</maml:title>
        <maml:introduction>
          <maml:para>```powershell
Get-PSReadLineOption
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```Output
EditMode                               : Windows
AddToHistoryHandler                    : System.Func`2[System.String,System.Object]
HistoryNoDuplicates                    : True
HistorySavePath                        : C:\Users\user1\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
HistorySaveStyle                       : SaveIncrementally
HistorySearchCaseSensitive             : False
HistorySearchCursorMovesToEnd          : False
MaximumHistoryCount                    : 4096
ContinuationPrompt                     : &gt;&gt;
ExtraPromptLineCount                   : 0
PromptText                             : {&gt; }
BellStyle                              : Audible
DingDuration                           : 50
DingTone                               : 1221
CommandsToValidateScriptBlockArguments : {ForEach-Object, %, Invoke-Command, icm…}
CommandValidationHandler               :
CompletionQueryItems                   : 100
MaximumKillRingCount                   : 10
ShowToolTips                           : True
ViModeIndicator                        : None
WordDelimiters                         : ;:,.[]{}()/\|!?^&amp;*-=+'"–—―
AnsiEscapeTimeout                      : 100
PredictionSource                       : HistoryAndPlugin
PredictionViewStyle                    : InlineView
TerminateOrphanedConsoleApps           : False
CommandColor                           : "`e[93m"
CommentColor                           : "`e[32m"
ContinuationPromptColor                : "`e[37m"
DefaultTokenColor                      : "`e[37m"
EmphasisColor                          : "`e[96m"
ErrorColor                             : "`e[91m"
InlinePredictionColor                  : "`e[97;2;3m"
KeywordColor                           : "`e[92m"
ListPredictionColor                    : "`e[33m"
ListPredictionSelectedColor            : "`e[48;5;238m"
ListPredictionTooltipColor             : "`e[97;2;3m"
MemberColor                            : "`e[37m"
NumberColor                            : "`e[97m"
OperatorColor                          : "`e[90m"
ParameterColor                         : "`e[90m"
SelectionColor                         : "`e[30;47m"
StringColor                            : "`e[36m"
TypeColor                              : "`e[37m"
VariableColor                          : "`e[92m"
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>This command returns the list of available PSReadLine options and their current values.</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
    </command:examples>
    <command:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Online Version</maml:linkText>
        <command:uri>https://learn.microsoft.com/powershell/module/psreadline/get-psreadlineoption?view=powershell-7.5&amp;WT.mc_id=ps-gethelp</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Remove-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Remove-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Get-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineOption</maml:linkText>
        <command:uri>Set-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Set-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
    </command:relatedLinks>
  </command:command>
  <command:command>
    <command:details>
      <command:name>Remove-PSReadLineKeyHandler</command:name>
      <maml:description>
        <maml:para>Removes a key binding.</maml:para>
      </maml:description>
      <command:verb>Remove</command:verb>
      <command:noun>PSReadLineKeyHandler</command:noun>
    </command:details>
    <maml:description>
      <maml:para>The `Remove-PSReadLineKeyHandler` cmdlet removes a specified key binding.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Remove-PSReadLineKeyHandler</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="0" aliases="none">
          <maml:name>Chord</maml:name>
          <maml:description>
            <maml:para>Specifies an array of keys or sequences of keys to be removed. A single binding is specified by
using a single string. If the binding is a sequence of keys, separate the keys by a comma, as in
the following example:</maml:para>
            <maml:para>`Ctrl+x,Ctrl+l`</maml:para>
            <maml:para>This parameter accepts an array of strings. Each string is a separate binding, not a sequence of
keys for a single binding.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">System.String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ViMode</maml:name>
          <maml:description>
            <maml:para>Specify which vi mode the binding applies to. Possible values are: Insert, Command.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.ViMode</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="0" aliases="none">
        <maml:name>Chord</maml:name>
        <maml:description>
          <maml:para>Specifies an array of keys or sequences of keys to be removed. A single binding is specified by
using a single string. If the binding is a sequence of keys, separate the keys by a comma, as in
the following example:</maml:para>
          <maml:para>`Ctrl+x,Ctrl+l`</maml:para>
          <maml:para>This parameter accepts an array of strings. Each string is a separate binding, not a sequence of
keys for a single binding.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">System.String[]</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>ViMode</maml:name>
        <maml:description>
          <maml:para>Specify which vi mode the binding applies to. Possible values are: Insert, Command.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.ViMode</command:parameterValue>
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>You can't pipe objects to this cmdlet.</maml:para>
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>This cmdlet returns no output.</maml:para>
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <maml:alertSet>
      <maml:alert>
        <maml:para />
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>--------- Example 1: Remove a binding ---------</maml:title>
        <maml:introduction>
          <maml:para>```powershell
Remove-PSReadLineKeyHandler -Chord Ctrl+B
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>This command removes the binding from the key combination, or chord, `Ctrl+B`. The `Ctrl+B` chord is
created in the `Set-PSReadLineKeyHandler` article.</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
    </command:examples>
    <command:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Online Version</maml:linkText>
        <command:uri>https://learn.microsoft.com/powershell/module/psreadline/remove-psreadlinekeyhandler?view=powershell-7.5&amp;WT.mc_id=ps-gethelp</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Get-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineOption</maml:linkText>
        <command:uri>Get-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineOption</maml:linkText>
        <command:uri>Set-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Set-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
    </command:relatedLinks>
  </command:command>
  <command:command>
    <command:details>
      <command:name>Set-PSReadLineKeyHandler</command:name>
      <maml:description>
        <maml:para>Binds keys to user-defined or PSReadLine key handler functions.</maml:para>
      </maml:description>
      <command:verb>Set</command:verb>
      <command:noun>PSReadLineKeyHandler</command:noun>
    </command:details>
    <maml:description>
      <maml:para>The `Set-PSReadLineKeyHandler` cmdlet customizes the result when a key or sequence of keys is pressed. With user-defined key bindings, you can do almost anything that's possible from within a PowerShell script.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Set-PSReadLineKeyHandler</maml:name>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>BriefDescription</maml:name>
          <maml:description>
            <maml:para>A brief description of the key binding. This description is displayed by the
`Get-PSReadLineKeyHandler` cmdlet.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="0" aliases="none">
          <maml:name>Chord</maml:name>
          <maml:description>
            <maml:para>The key or sequence of keys to be bound to a function or script block. Use a single string to
specify a single binding. If the binding is a sequence of keys, separate the keys by a comma. For
example: `Ctrl+x,Ctrl+l`</maml:para>
            <maml:para>Letter key references are defined using lowercase letters. If you want to define a chord that uses
an uppercase letter, the chord must include the **Shift** key. For example, `Ctrl+Shift+x` and
`Ctrl+x` create different bindings.</maml:para>
            <maml:para>This parameter accepts an array of strings. Each string is a separate binding, not a sequence of
keys for a single binding.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">System.String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>Description</maml:name>
          <maml:description>
            <maml:para>Specifies a more detailed description of the key binding that's visible in the output of the
`Get-PSReadLineKeyHandler` cmdlet.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="none">
          <maml:name>ScriptBlock</maml:name>
          <maml:description>
            <maml:para>Specifies a script block value to run when the chord is entered. PSReadLine passes one or two
parameters to this script block. The first parameter is a **ConsoleKeyInfo** object representing the
key pressed. The second argument can be any object depending on the context.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">System.Management.Automation.ScriptBlock</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ViMode</maml:name>
          <maml:description>
            <maml:para>Specify which vi mode the binding applies to.</maml:para>
            <maml:para>Valid values are:</maml:para>
            <maml:para>- `Insert`
- `Command`</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.ViMode</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Set-PSReadLineKeyHandler</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="0" aliases="none">
          <maml:name>Chord</maml:name>
          <maml:description>
            <maml:para>The key or sequence of keys to be bound to a function or script block. Use a single string to
specify a single binding. If the binding is a sequence of keys, separate the keys by a comma. For
example: `Ctrl+x,Ctrl+l`</maml:para>
            <maml:para>Letter key references are defined using lowercase letters. If you want to define a chord that uses
an uppercase letter, the chord must include the **Shift** key. For example, `Ctrl+Shift+x` and
`Ctrl+x` create different bindings.</maml:para>
            <maml:para>This parameter accepts an array of strings. Each string is a separate binding, not a sequence of
keys for a single binding.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">System.String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="none">
          <maml:name>Function</maml:name>
          <maml:description>
            <maml:para>Specifies the name of an existing key handler provided by PSReadLine. This parameter lets you rebind
existing key bindings, or bind a handler that's currently unbound.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">System.String</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ViMode</maml:name>
          <maml:description>
            <maml:para>Specify which vi mode the binding applies to.</maml:para>
            <maml:para>Valid values are:</maml:para>
            <maml:para>- `Insert`
- `Command`</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.ViMode</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>BriefDescription</maml:name>
        <maml:description>
          <maml:para>A brief description of the key binding. This description is displayed by the
`Get-PSReadLineKeyHandler` cmdlet.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="0" aliases="none">
        <maml:name>Chord</maml:name>
        <maml:description>
          <maml:para>The key or sequence of keys to be bound to a function or script block. Use a single string to
specify a single binding. If the binding is a sequence of keys, separate the keys by a comma. For
example: `Ctrl+x,Ctrl+l`</maml:para>
          <maml:para>Letter key references are defined using lowercase letters. If you want to define a chord that uses
an uppercase letter, the chord must include the **Shift** key. For example, `Ctrl+Shift+x` and
`Ctrl+x` create different bindings.</maml:para>
          <maml:para>This parameter accepts an array of strings. Each string is a separate binding, not a sequence of
keys for a single binding.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">System.String[]</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>Description</maml:name>
        <maml:description>
          <maml:para>Specifies a more detailed description of the key binding that's visible in the output of the
`Get-PSReadLineKeyHandler` cmdlet.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="none">
        <maml:name>Function</maml:name>
        <maml:description>
          <maml:para>Specifies the name of an existing key handler provided by PSReadLine. This parameter lets you rebind
existing key bindings, or bind a handler that's currently unbound.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">System.String</command:parameterValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="none">
        <maml:name>ScriptBlock</maml:name>
        <maml:description>
          <maml:para>Specifies a script block value to run when the chord is entered. PSReadLine passes one or two
parameters to this script block. The first parameter is a **ConsoleKeyInfo** object representing the
key pressed. The second argument can be any object depending on the context.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">System.Management.Automation.ScriptBlock</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>ViMode</maml:name>
        <maml:description>
          <maml:para>Specify which vi mode the binding applies to.</maml:para>
          <maml:para>Valid values are:</maml:para>
          <maml:para>- `Insert`
- `Command`</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.ViMode</command:parameterValue>
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>You can't pipe objects to this cmdlet.</maml:para>
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>This cmdlet returns no output.</maml:para>
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <maml:alertSet>
      <maml:alert>
        <maml:para />
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>--------- Example 1: Bind the arrow key to a function ---------</maml:title>
        <maml:introduction>
          <maml:para>This command binds the up arrow key to the **HistorySearchBackward** function. This function
searches command history for command lines that start with the current contents of the command line.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Set-PSReadLineKeyHandler -Chord UpArrow -Function HistorySearchBackward
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 2: Bind a key to a script block ---------</maml:title>
        <maml:introduction>
          <maml:para>This example shows how a single key can be used to run a command. The command binds the key `Ctrl+b`
to a script block that clears the line, inserts the word "build", and then accepts the line.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Set-PSReadLineKeyHandler -Chord Ctrl+b -ScriptBlock {
    [Microsoft.PowerShell.PSConsoleReadLine]::RevertLine()
    [Microsoft.PowerShell.PSConsoleReadLine]::Insert('build')
    [Microsoft.PowerShell.PSConsoleReadLine]::AcceptLine()
}
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
    </command:examples>
    <command:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Online Version</maml:linkText>
        <command:uri>https://learn.microsoft.com/powershell/module/psreadline/set-psreadlinekeyhandler?view=powershell-7.5&amp;WT.mc_id=ps-gethelp</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Get-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Remove-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Remove-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineOption</maml:linkText>
        <command:uri>Get-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineOption</maml:linkText>
        <command:uri>Set-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
    </command:relatedLinks>
  </command:command>
  <command:command>
    <command:details>
      <command:name>Set-PSReadLineOption</command:name>
      <maml:description>
        <maml:para>Customizes the behavior of command line editing in **PSReadLine**.</maml:para>
      </maml:description>
      <command:verb>Set</command:verb>
      <command:noun>PSReadLineOption</command:noun>
    </command:details>
    <maml:description>
      <maml:para>The `Set-PSReadLineOption` cmdlet customizes the behavior of the **PSReadLine** module when you're editing the command line. To view the **PSReadLine** settings, use `Get-PSReadLineOption`.</maml:para>
      <maml:para>The options set by this command only apply to the current session. To persist any options, add them to a profile script. For more information, see [about_Profiles](../Microsoft.PowerShell.Core/About/about_Profiles.md) and [Customizing your shell environment](/powershell/scripting/learn/shell/creating-profiles).</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Set-PSReadLineOption</maml:name>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>AddToHistoryHandler</maml:name>
          <maml:description>
            <maml:para>Specifies a **ScriptBlock** that controls how commands get added to **PSReadLine** history.</maml:para>
            <maml:para>The **ScriptBlock** receives the command line as input.</maml:para>
            <maml:para>The  **ScripBlock** should return a member of the **AddToHistoryOption** enum, the string name of
one of those members, or a boolean value. The list below describes the possible values and their
effects.</maml:para>
            <maml:para>- `MemoryAndFile` - Add the command to the history file and the current session.
- `MemoryOnly` - Add the command to history for the current session only.
- `SkipAdding` - Don't add the command to the history file for current session.
- `$false` - Same as if the value was `SkipAdding`.
- `$true` - Same as if the value was `MemoryAndFile`.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Func`2[System.String,System.Object]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>AnsiEscapeTimeout</maml:name>
          <maml:description>
            <maml:para>This option is specific to Windows when input is redirected, for example, when running under `tmux`
or `screen`.</maml:para>
            <maml:para>With redirected input on Windows, many keys are sent as a sequence of characters starting with the
escape character. It's impossible to distinguish between a single escape character followed by
more characters and a valid escape sequence.</maml:para>
            <maml:para>The assumption is that the terminal can send the characters faster than a user types. **PSReadLine**
waits for this timeout before concluding that it has received a complete escape sequence.</maml:para>
            <maml:para>If you see random or unexpected characters when you type, you can adjust this timeout.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>BellStyle</maml:name>
          <maml:description>
            <maml:para>Specifies how **PSReadLine** responds to various error and ambiguous conditions.</maml:para>
            <maml:para>The valid values are as follows:</maml:para>
            <maml:para>- **Audible**: A short beep.
- **Visual**: Text flashes briefly.
- **None**: No feedback.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.BellStyle</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>Colors</maml:name>
          <maml:description>
            <maml:para>The **Colors** parameter specifies various colors used by **PSReadLine**.</maml:para>
            <maml:para>The argument is a hash table where the keys specify the elements and the values specify the color.
For more information, see
[about_Hash_Tables](/powershell/module/microsoft.powershell.core/about/about_hash_tables).</maml:para>
            <maml:para>Colors can be either a value from **ConsoleColor**, for example `[ConsoleColor]::Red`, or a valid
ANSI escape sequence. Valid escape sequences depend on your terminal. In PowerShell 5.0, an example
escape sequence for red text is `$([char]0x1b)[91m`. In PowerShell 6 and newer, the same escape
sequence is `` `e[91m``. You can specify other escape sequences including the following types:</maml:para>
            <maml:para>Two color settings were added to support customization of the `ListView` in PSReadLine 2.2.0:</maml:para>
            <maml:para>- **ListPredictionColor** - set color for the leading `&gt;` character and the trailing source name,
  such as `[History]`. By default, it uses `DarkYellow` as the foreground color.
- **ListPredictionSelectedColor** - set color for indicating a list item is selected. By default, it
  uses `DarkBlack` as the background color.</maml:para>
            <maml:para>- 256 color
- 24-bit color
- Foreground, background, or both
- Inverse, bold</maml:para>
            <maml:para>For more information about ANSI color codes, see the Wikipedia article
[ANSI escape code](https://wikipedia.org/wiki/ANSI_escape_code#Colors_).</maml:para>
            <maml:para>The valid keys include:</maml:para>
            <maml:para>- **ContinuationPrompt**: The color of the continuation prompt.
- **Emphasis**: The emphasis color. For example, the matching text when searching history.
- **Error**: The error color. For example, in the prompt.
- **Selection**: The color to highlight the menu selection or selected text.
- **Default**: The default token color.
- **Comment**: The comment token color.
- **Keyword**: The keyword token color.
- **String**: The string token color.
- **Operator**: The operator token color.
- **Variable**: The variable token color.
- **Command**: The command token color.
- **Parameter**: The parameter token color.
- **Type**: The type token color.
- **Number**: The number token color.
- **Member**: The member name token color.
- **InlinePrediction**: The color for the inline view of the predictive suggestion.
- **ListPrediction**: The color for the leading `&gt;` character and prediction source name.
- **ListPredictionSelected**: The color for the selected prediction in list view.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Collections.Hashtable</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>CommandValidationHandler</maml:name>
          <maml:description>
            <maml:para>Specifies a **ScriptBlock** that is called from **ValidateAndAcceptLine**. If an exception is
thrown, validation fails and the error is reported.</maml:para>
            <maml:para>Before throwing an exception, the validation handler can place the cursor at the point of the error
to make it easier to fix. A validation handler can also change the command line to correct common
typographical errors.</maml:para>
            <maml:para>**ValidateAndAcceptLine** is used to avoid cluttering your history with commands that can't work.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Action`1[System.Management.Automation.Language.CommandAst]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>CompletionQueryItems</maml:name>
          <maml:description>
            <maml:para>Specifies the maximum number of completion items that are shown without prompting.</maml:para>
            <maml:para>If the number of items to show is greater than this value, **PSReadLine** prompts **yes/no** before
displaying the completion items.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ContinuationPrompt</maml:name>
          <maml:description>
            <maml:para>Specifies the string displayed at the beginning of the subsequent lines when multi-line input is
entered. The default is double greater-than signs (`&gt;&gt;`). An empty string is valid.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>DingDuration</maml:name>
          <maml:description>
            <maml:para>Specifies the duration of the beep when **BellStyle** is set to **Audible**.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>DingTone</maml:name>
          <maml:description>
            <maml:para>Specifies the tone in Hertz (Hz) of the beep when **BellStyle** is set to **Audible**.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>EditMode</maml:name>
          <maml:description>
            <maml:para>Specifies the command line editing mode. Using this parameter resets any key bindings set by
`Set-PSReadLineKeyHandler`.</maml:para>
            <maml:para>The valid values are as follows:</maml:para>
            <maml:para>- **Windows**: Key bindings emulate PowerShell, cmd, and Visual Studio. (default on Windows)
- **Emacs**: Key bindings emulate Bash or Emacs. (default on non-Windows platforms)
- **Vi**: Key bindings emulate Vi.</maml:para>
            <maml:para>Use `Get-PSReadLineKeyHandler` to see the key bindings for the currently configured **EditMode**.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.EditMode</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ExtraPromptLineCount</maml:name>
          <maml:description>
            <maml:para>Specifies the number of extra lines.</maml:para>
            <maml:para>If your prompt spans more than one line, specify a value for this parameter. Use this option when
you want extra lines to be available when **PSReadLine** displays the prompt after showing some
output. For example, **PSReadLine** returns a list of completions.</maml:para>
            <maml:para>This option is needed less than in previous versions of **PSReadLine**, but is useful when the
`InvokePrompt` function is used.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>HistoryNoDuplicates</maml:name>
          <maml:description>
            <maml:para>This option controls the recall behavior. Duplicate commands are still added to the history file.
When this option is set, only the most recent invocation appears when recalling commands. Repeated
commands are added to history to preserve ordering during recall. However, you typically don't want
to see the command multiple times when recalling or searching the history.</maml:para>
            <maml:para>By default, the **HistoryNoDuplicates** property of the global **PSConsoleReadLineOptions** object
is set to `True`. To change the property value, you must specify the value of the
**SwitchParameter** as follows: `-HistoryNoDuplicates:$false`. You can set back to `True` by using
just the **SwitchParameter**, `-HistoryNoDuplicates`.</maml:para>
            <maml:para>Using the following command, you can set the property value directly:</maml:para>
            <maml:para>`(Get-PSReadLineOption).HistoryNoDuplicates = $false`</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>HistorySavePath</maml:name>
          <maml:description>
            <maml:para>Specifies the path to the file where history is saved. Computers running Windows or non-Windows
platforms store the file in different locations. The filename is stored in a variable
`$($Host.Name)_history.txt`, for example `ConsoleHost_history.txt`.</maml:para>
            <maml:para>If you don't use this parameter, the default path is as follows:</maml:para>
            <maml:para>**Windows**</maml:para>
            <maml:para>- `$Env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\$($Host.Name)_history.txt`</maml:para>
            <maml:para>**non-Windows**</maml:para>
            <maml:para>- `$Env:XDG_DATA_HOME/powershell/PSReadLine/$($Host.Name)_history.txt`
- `$HOME/.local/share/powershell/PSReadLine/$($Host.Name)_history.txt`</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>HistorySaveStyle</maml:name>
          <maml:description>
            <maml:para>Specifies how **PSReadLine** saves history.</maml:para>
            <maml:para>Valid values are as follows:</maml:para>
            <maml:para>- `SaveIncrementally`: Save history after each command is executed and share across multiple
  instances of PowerShell.
- `SaveAtExit`: Append history file when PowerShell exits.
- `SaveNothing`: Don't use a history file.</maml:para>
            <maml:para>&gt; [!NOTE]
&gt; If you set **HistorySaveStyle** to `SaveNothing` and then set it to `SaveIncrementally` later in
&gt; the same session, PSReadLine saves all the commands previously run in the session.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.HistorySaveStyle</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>HistorySearchCaseSensitive</maml:name>
          <maml:description>
            <maml:para>Specifies that history searching is case-sensitive in functions like **ReverseSearchHistory** or
**HistorySearchBackward**.</maml:para>
            <maml:para>By default, the **HistorySearchCaseSensitive** property of the global **PSConsoleReadLineOptions**
object is set to `False`. Using this **SwitchParameter** sets the property value to `True`. To
change the property value back, you must specify the value of the **SwitchParameter** as follows:
`-HistorySearchCaseSensitive:$false`.</maml:para>
            <maml:para>Using the following command, you can set the property value directly:</maml:para>
            <maml:para>`(Get-PSReadLineOption).HistorySearchCaseSensitive = $false`</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>HistorySearchCursorMovesToEnd</maml:name>
          <maml:description>
            <maml:para>Indicates that the cursor moves to the end of commands that you load from history by using a search.
When this parameter is set to `$false`, the cursor remains at the position it was when you pressed
the up or down arrows.</maml:para>
            <maml:para>By default, the **HistorySearchCursorMovesToEnd** property of the global
**PSConsoleReadLineOptions** object is set to `False`. Using this **SwitchParameter** set the
property value to `True`. To change the property value back, you must specify the value of the
**SwitchParameter** as follows: `-HistorySearchCursorMovesToEnd:$false`.</maml:para>
            <maml:para>Using the following command, you can set the property value directly:</maml:para>
            <maml:para>`(Get-PSReadLineOption).HistorySearchCursorMovesToEnd = $false`</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>MaximumHistoryCount</maml:name>
          <maml:description>
            <maml:para>Specifies the maximum number of commands to save in **PSReadLine** history.</maml:para>
            <maml:para>**PSReadLine** history is separate from PowerShell history.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>MaximumKillRingCount</maml:name>
          <maml:description>
            <maml:para>Specifies the maximum number of items stored in the kill ring.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>PredictionSource</maml:name>
          <maml:description>
            <maml:para>Specifies the source for PSReadLine to get predictive suggestions.</maml:para>
            <maml:para>Valid values are:</maml:para>
            <maml:para>- **None** - disable the predictive IntelliSense feature (default).
- **History** - enable the predictive IntelliSense feature and use the PSReadLine history as the
  only source.
- **Plugin** - enable the predictive IntelliSense feature and use the plugins (`CommandPrediction`)
  as the only source. This value was added in PSReadLine 2.2.0
- **HistoryAndPlugin** - enable the predictive IntelliSense feature and use both history and plugin
  as the sources. This value was added in PSReadLine 2.2.0</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.PredictionSource</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>PredictionViewStyle</maml:name>
          <maml:description>
            <maml:para>Sets the style for the display of the predictive text. The default is **InlineView**.</maml:para>
            <maml:para>- **InlineView** - the style as existing today, similar as in fish shell and zsh. (default)
- **ListView** - suggestions are rendered in a drop down list, and users can select using
  &lt;kbd&gt;UpArrow&lt;/kbd&gt; and &lt;kbd&gt;DownArrow&lt;/kbd&gt;.</maml:para>
            <maml:para>This parameter was added in PSReadLine 2.2.0</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.PredictionViewStyle</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>PromptText</maml:name>
          <maml:description>
            <maml:para>This parameter sets the value of the **PromptText** property. The default value is `"&gt; "`.</maml:para>
            <maml:para>**PSReadLine** analyzes your prompt function to determine how to change only the color of part of
your prompt. This analysis isn't 100% reliable. Use this option if **PSReadLine** is changing your
prompt in unexpected ways. Include any trailing whitespace.</maml:para>
            <maml:para>The value of this parameter can be a single string or an array of two strings. The first string is
the portion of your prompt string that you want to be changed to red when there is a parse error.
The second string is an alternate string to use for when there is a parse error.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ShowToolTips</maml:name>
          <maml:description>
            <maml:para>When displaying possible completions, tooltips are shown in the list of completions.</maml:para>
            <maml:para>This option is enabled by default. This option wasn't enabled by default in prior versions of
**PSReadLine**. To disable, set this option to `$false`.</maml:para>
            <maml:para>This parameter and option were added in PSReadLine 2.3.4.</maml:para>
            <maml:para>By default, the **ShowToolTips** property of the global **PSConsoleReadLineOptions** object is set
to `True`. Using this **SwitchParameter** sets the property value to `True`. To change the property
value, you must specify the value of the **SwitchParameter** as follows: `-ShowToolTips:$false`.</maml:para>
            <maml:para>Using the following command, you can set the property value directly:</maml:para>
            <maml:para>`(Get-PSReadLineOption).ShowToolTips = $false`</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>TerminateOrphanedConsoleApps</maml:name>
          <maml:description>
            <maml:para>This parameter sets the **TerminateOrphanedConsoleApps** option to `$true`.</maml:para>
            <maml:para>On Windows, when you press &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;c&lt;/kbd&gt; to terminate a process, each process
attached to a console receives a terminate signal, as opposed to just the active shell. Sometimes,
when a shell has launched some large tree of child processes, (imagine a build system, for example)
some processes may exit, leaving multiple processes concurrently trying to consume console input.</maml:para>
            <maml:para>When setting the **TerminateOrphanedConsoleApps** option to `$true`, PSReadLine records the list of
processes that are currently attached to the console. Afterwards, whenever PSReadLine runs, it will
get a new list of processes attached to the console, and terminate those that aren't in the original
list.</maml:para>
            <maml:para>This parameter and option were added in PSReadLine 2.3.4.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ViModeChangeHandler</maml:name>
          <maml:description>
            <maml:para>When the **ViModeIndicator** is set to `Script`, the script block provided will be invoked every
time the mode changes. The script block is provided one argument of type `ViMode`.</maml:para>
            <maml:para>This parameter was introduced in PowerShell 7.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.Management.Automation.ScriptBlock</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>ViModeIndicator</maml:name>
          <maml:description>
            <maml:para>This option sets the visual indicator for the current **Vi** mode. Either insert mode or command
mode.</maml:para>
            <maml:para>The valid values are as follows:</maml:para>
            <maml:para>- **None**: There's no indicator.
- **Prompt**: The prompt changes color.
- **Cursor**: The cursor changes size.
- **Script**: User-specified text is printed.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.ViModeStyle</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
          <maml:name>WordDelimiters</maml:name>
          <maml:description>
            <maml:para>Specifies the characters that delimit words for functions like **ForwardWord** or **KillWord**.</maml:para>
          </maml:description>
          <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>AddToHistoryHandler</maml:name>
        <maml:description>
          <maml:para>Specifies a **ScriptBlock** that controls how commands get added to **PSReadLine** history.</maml:para>
          <maml:para>The **ScriptBlock** receives the command line as input.</maml:para>
          <maml:para>The  **ScripBlock** should return a member of the **AddToHistoryOption** enum, the string name of
one of those members, or a boolean value. The list below describes the possible values and their
effects.</maml:para>
          <maml:para>- `MemoryAndFile` - Add the command to the history file and the current session.
- `MemoryOnly` - Add the command to history for the current session only.
- `SkipAdding` - Don't add the command to the history file for current session.
- `$false` - Same as if the value was `SkipAdding`.
- `$true` - Same as if the value was `MemoryAndFile`.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Func`2[System.String,System.Object]</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>AnsiEscapeTimeout</maml:name>
        <maml:description>
          <maml:para>This option is specific to Windows when input is redirected, for example, when running under `tmux`
or `screen`.</maml:para>
          <maml:para>With redirected input on Windows, many keys are sent as a sequence of characters starting with the
escape character. It's impossible to distinguish between a single escape character followed by
more characters and a valid escape sequence.</maml:para>
          <maml:para>The assumption is that the terminal can send the characters faster than a user types. **PSReadLine**
waits for this timeout before concluding that it has received a complete escape sequence.</maml:para>
          <maml:para>If you see random or unexpected characters when you type, you can adjust this timeout.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>BellStyle</maml:name>
        <maml:description>
          <maml:para>Specifies how **PSReadLine** responds to various error and ambiguous conditions.</maml:para>
          <maml:para>The valid values are as follows:</maml:para>
          <maml:para>- **Audible**: A short beep.
- **Visual**: Text flashes briefly.
- **None**: No feedback.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.BellStyle</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>Colors</maml:name>
        <maml:description>
          <maml:para>The **Colors** parameter specifies various colors used by **PSReadLine**.</maml:para>
          <maml:para>The argument is a hash table where the keys specify the elements and the values specify the color.
For more information, see
[about_Hash_Tables](/powershell/module/microsoft.powershell.core/about/about_hash_tables).</maml:para>
          <maml:para>Colors can be either a value from **ConsoleColor**, for example `[ConsoleColor]::Red`, or a valid
ANSI escape sequence. Valid escape sequences depend on your terminal. In PowerShell 5.0, an example
escape sequence for red text is `$([char]0x1b)[91m`. In PowerShell 6 and newer, the same escape
sequence is `` `e[91m``. You can specify other escape sequences including the following types:</maml:para>
          <maml:para>Two color settings were added to support customization of the `ListView` in PSReadLine 2.2.0:</maml:para>
          <maml:para>- **ListPredictionColor** - set color for the leading `&gt;` character and the trailing source name,
  such as `[History]`. By default, it uses `DarkYellow` as the foreground color.
- **ListPredictionSelectedColor** - set color for indicating a list item is selected. By default, it
  uses `DarkBlack` as the background color.</maml:para>
          <maml:para>- 256 color
- 24-bit color
- Foreground, background, or both
- Inverse, bold</maml:para>
          <maml:para>For more information about ANSI color codes, see the Wikipedia article
[ANSI escape code](https://wikipedia.org/wiki/ANSI_escape_code#Colors_).</maml:para>
          <maml:para>The valid keys include:</maml:para>
          <maml:para>- **ContinuationPrompt**: The color of the continuation prompt.
- **Emphasis**: The emphasis color. For example, the matching text when searching history.
- **Error**: The error color. For example, in the prompt.
- **Selection**: The color to highlight the menu selection or selected text.
- **Default**: The default token color.
- **Comment**: The comment token color.
- **Keyword**: The keyword token color.
- **String**: The string token color.
- **Operator**: The operator token color.
- **Variable**: The variable token color.
- **Command**: The command token color.
- **Parameter**: The parameter token color.
- **Type**: The type token color.
- **Number**: The number token color.
- **Member**: The member name token color.
- **InlinePrediction**: The color for the inline view of the predictive suggestion.
- **ListPrediction**: The color for the leading `&gt;` character and prediction source name.
- **ListPredictionSelected**: The color for the selected prediction in list view.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Collections.Hashtable</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>CommandValidationHandler</maml:name>
        <maml:description>
          <maml:para>Specifies a **ScriptBlock** that is called from **ValidateAndAcceptLine**. If an exception is
thrown, validation fails and the error is reported.</maml:para>
          <maml:para>Before throwing an exception, the validation handler can place the cursor at the point of the error
to make it easier to fix. A validation handler can also change the command line to correct common
typographical errors.</maml:para>
          <maml:para>**ValidateAndAcceptLine** is used to avoid cluttering your history with commands that can't work.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Action`1[System.Management.Automation.Language.CommandAst]</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>CompletionQueryItems</maml:name>
        <maml:description>
          <maml:para>Specifies the maximum number of completion items that are shown without prompting.</maml:para>
          <maml:para>If the number of items to show is greater than this value, **PSReadLine** prompts **yes/no** before
displaying the completion items.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>ContinuationPrompt</maml:name>
        <maml:description>
          <maml:para>Specifies the string displayed at the beginning of the subsequent lines when multi-line input is
entered. The default is double greater-than signs (`&gt;&gt;`). An empty string is valid.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>DingDuration</maml:name>
        <maml:description>
          <maml:para>Specifies the duration of the beep when **BellStyle** is set to **Audible**.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>DingTone</maml:name>
        <maml:description>
          <maml:para>Specifies the tone in Hertz (Hz) of the beep when **BellStyle** is set to **Audible**.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>EditMode</maml:name>
        <maml:description>
          <maml:para>Specifies the command line editing mode. Using this parameter resets any key bindings set by
`Set-PSReadLineKeyHandler`.</maml:para>
          <maml:para>The valid values are as follows:</maml:para>
          <maml:para>- **Windows**: Key bindings emulate PowerShell, cmd, and Visual Studio. (default on Windows)
- **Emacs**: Key bindings emulate Bash or Emacs. (default on non-Windows platforms)
- **Vi**: Key bindings emulate Vi.</maml:para>
          <maml:para>Use `Get-PSReadLineKeyHandler` to see the key bindings for the currently configured **EditMode**.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.EditMode</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>ExtraPromptLineCount</maml:name>
        <maml:description>
          <maml:para>Specifies the number of extra lines.</maml:para>
          <maml:para>If your prompt spans more than one line, specify a value for this parameter. Use this option when
you want extra lines to be available when **PSReadLine** displays the prompt after showing some
output. For example, **PSReadLine** returns a list of completions.</maml:para>
          <maml:para>This option is needed less than in previous versions of **PSReadLine**, but is useful when the
`InvokePrompt` function is used.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>HistoryNoDuplicates</maml:name>
        <maml:description>
          <maml:para>This option controls the recall behavior. Duplicate commands are still added to the history file.
When this option is set, only the most recent invocation appears when recalling commands. Repeated
commands are added to history to preserve ordering during recall. However, you typically don't want
to see the command multiple times when recalling or searching the history.</maml:para>
          <maml:para>By default, the **HistoryNoDuplicates** property of the global **PSConsoleReadLineOptions** object
is set to `True`. To change the property value, you must specify the value of the
**SwitchParameter** as follows: `-HistoryNoDuplicates:$false`. You can set back to `True` by using
just the **SwitchParameter**, `-HistoryNoDuplicates`.</maml:para>
          <maml:para>Using the following command, you can set the property value directly:</maml:para>
          <maml:para>`(Get-PSReadLineOption).HistoryNoDuplicates = $false`</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>HistorySavePath</maml:name>
        <maml:description>
          <maml:para>Specifies the path to the file where history is saved. Computers running Windows or non-Windows
platforms store the file in different locations. The filename is stored in a variable
`$($Host.Name)_history.txt`, for example `ConsoleHost_history.txt`.</maml:para>
          <maml:para>If you don't use this parameter, the default path is as follows:</maml:para>
          <maml:para>**Windows**</maml:para>
          <maml:para>- `$Env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\$($Host.Name)_history.txt`</maml:para>
          <maml:para>**non-Windows**</maml:para>
          <maml:para>- `$Env:XDG_DATA_HOME/powershell/PSReadLine/$($Host.Name)_history.txt`
- `$HOME/.local/share/powershell/PSReadLine/$($Host.Name)_history.txt`</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>HistorySaveStyle</maml:name>
        <maml:description>
          <maml:para>Specifies how **PSReadLine** saves history.</maml:para>
          <maml:para>Valid values are as follows:</maml:para>
          <maml:para>- `SaveIncrementally`: Save history after each command is executed and share across multiple
  instances of PowerShell.
- `SaveAtExit`: Append history file when PowerShell exits.
- `SaveNothing`: Don't use a history file.</maml:para>
          <maml:para>&gt; [!NOTE]
&gt; If you set **HistorySaveStyle** to `SaveNothing` and then set it to `SaveIncrementally` later in
&gt; the same session, PSReadLine saves all the commands previously run in the session.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.HistorySaveStyle</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>HistorySearchCaseSensitive</maml:name>
        <maml:description>
          <maml:para>Specifies that history searching is case-sensitive in functions like **ReverseSearchHistory** or
**HistorySearchBackward**.</maml:para>
          <maml:para>By default, the **HistorySearchCaseSensitive** property of the global **PSConsoleReadLineOptions**
object is set to `False`. Using this **SwitchParameter** sets the property value to `True`. To
change the property value back, you must specify the value of the **SwitchParameter** as follows:
`-HistorySearchCaseSensitive:$false`.</maml:para>
          <maml:para>Using the following command, you can set the property value directly:</maml:para>
          <maml:para>`(Get-PSReadLineOption).HistorySearchCaseSensitive = $false`</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>HistorySearchCursorMovesToEnd</maml:name>
        <maml:description>
          <maml:para>Indicates that the cursor moves to the end of commands that you load from history by using a search.
When this parameter is set to `$false`, the cursor remains at the position it was when you pressed
the up or down arrows.</maml:para>
          <maml:para>By default, the **HistorySearchCursorMovesToEnd** property of the global
**PSConsoleReadLineOptions** object is set to `False`. Using this **SwitchParameter** set the
property value to `True`. To change the property value back, you must specify the value of the
**SwitchParameter** as follows: `-HistorySearchCursorMovesToEnd:$false`.</maml:para>
          <maml:para>Using the following command, you can set the property value directly:</maml:para>
          <maml:para>`(Get-PSReadLineOption).HistorySearchCursorMovesToEnd = $false`</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>MaximumHistoryCount</maml:name>
        <maml:description>
          <maml:para>Specifies the maximum number of commands to save in **PSReadLine** history.</maml:para>
          <maml:para>**PSReadLine** history is separate from PowerShell history.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>MaximumKillRingCount</maml:name>
        <maml:description>
          <maml:para>Specifies the maximum number of items stored in the kill ring.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Int32</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>PredictionSource</maml:name>
        <maml:description>
          <maml:para>Specifies the source for PSReadLine to get predictive suggestions.</maml:para>
          <maml:para>Valid values are:</maml:para>
          <maml:para>- **None** - disable the predictive IntelliSense feature (default).
- **History** - enable the predictive IntelliSense feature and use the PSReadLine history as the
  only source.
- **Plugin** - enable the predictive IntelliSense feature and use the plugins (`CommandPrediction`)
  as the only source. This value was added in PSReadLine 2.2.0
- **HistoryAndPlugin** - enable the predictive IntelliSense feature and use both history and plugin
  as the sources. This value was added in PSReadLine 2.2.0</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.PredictionSource</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>PredictionViewStyle</maml:name>
        <maml:description>
          <maml:para>Sets the style for the display of the predictive text. The default is **InlineView**.</maml:para>
          <maml:para>- **InlineView** - the style as existing today, similar as in fish shell and zsh. (default)
- **ListView** - suggestions are rendered in a drop down list, and users can select using
  &lt;kbd&gt;UpArrow&lt;/kbd&gt; and &lt;kbd&gt;DownArrow&lt;/kbd&gt;.</maml:para>
          <maml:para>This parameter was added in PSReadLine 2.2.0</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.PredictionViewStyle</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>PromptText</maml:name>
        <maml:description>
          <maml:para>This parameter sets the value of the **PromptText** property. The default value is `"&gt; "`.</maml:para>
          <maml:para>**PSReadLine** analyzes your prompt function to determine how to change only the color of part of
your prompt. This analysis isn't 100% reliable. Use this option if **PSReadLine** is changing your
prompt in unexpected ways. Include any trailing whitespace.</maml:para>
          <maml:para>The value of this parameter can be a single string or an array of two strings. The first string is
the portion of your prompt string that you want to be changed to red when there is a parse error.
The second string is an alternate string to use for when there is a parse error.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.String[]</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>ShowToolTips</maml:name>
        <maml:description>
          <maml:para>When displaying possible completions, tooltips are shown in the list of completions.</maml:para>
          <maml:para>This option is enabled by default. This option wasn't enabled by default in prior versions of
**PSReadLine**. To disable, set this option to `$false`.</maml:para>
          <maml:para>This parameter and option were added in PSReadLine 2.3.4.</maml:para>
          <maml:para>By default, the **ShowToolTips** property of the global **PSConsoleReadLineOptions** object is set
to `True`. Using this **SwitchParameter** sets the property value to `True`. To change the property
value, you must specify the value of the **SwitchParameter** as follows: `-ShowToolTips:$false`.</maml:para>
          <maml:para>Using the following command, you can set the property value directly:</maml:para>
          <maml:para>`(Get-PSReadLineOption).ShowToolTips = $false`</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>TerminateOrphanedConsoleApps</maml:name>
        <maml:description>
          <maml:para>This parameter sets the **TerminateOrphanedConsoleApps** option to `$true`.</maml:para>
          <maml:para>On Windows, when you press &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;c&lt;/kbd&gt; to terminate a process, each process
attached to a console receives a terminate signal, as opposed to just the active shell. Sometimes,
when a shell has launched some large tree of child processes, (imagine a build system, for example)
some processes may exit, leaving multiple processes concurrently trying to consume console input.</maml:para>
          <maml:para>When setting the **TerminateOrphanedConsoleApps** option to `$true`, PSReadLine records the list of
processes that are currently attached to the console. Afterwards, whenever PSReadLine runs, it will
get a new list of processes attached to the console, and terminate those that aren't in the original
list.</maml:para>
          <maml:para>This parameter and option were added in PSReadLine 2.3.4.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.SwitchParameter</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>ViModeChangeHandler</maml:name>
        <maml:description>
          <maml:para>When the **ViModeIndicator** is set to `Script`, the script block provided will be invoked every
time the mode changes. The script block is provided one argument of type `ViMode`.</maml:para>
          <maml:para>This parameter was introduced in PowerShell 7.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.Management.Automation.ScriptBlock</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>ViModeIndicator</maml:name>
        <maml:description>
          <maml:para>This option sets the visual indicator for the current **Vi** mode. Either insert mode or command
mode.</maml:para>
          <maml:para>The valid values are as follows:</maml:para>
          <maml:para>- **None**: There's no indicator.
- **Prompt**: The prompt changes color.
- **Cursor**: The cursor changes size.
- **Script**: User-specified text is printed.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">Microsoft.PowerShell.ViModeStyle</command:parameterValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="Named" aliases="none">
        <maml:name>WordDelimiters</maml:name>
        <maml:description>
          <maml:para>Specifies the characters that delimit words for functions like **ForwardWord** or **KillWord**.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="true">System.String</command:parameterValue>
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>You can't pipe objects to this cmdlet.</maml:para>
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <dev:name>None</dev:name>
        </dev:type>
        <maml:description>
          <maml:para>This cmdlet returns no output.</maml:para>
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <maml:alertSet>
      <maml:alert>
        <maml:para />
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>--------- Example 1: Set foreground and background colors ---------</maml:title>
        <maml:introduction>
          <maml:para>This example sets **PSReadLine** to display the **Comment** token with green foreground text on a
gray background. In the escape sequence used in the example, **32** represents the foreground color
and **47** represents the background color.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Set-PSReadLineOption -Colors @{ "Comment"="`e[32;47m" }
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>You can choose to set only a foreground text color. For example, a bright green foreground text
color for the **Comment** token: ``"Comment"="`e[92m"``.</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 2: Set bell style ---------</maml:title>
        <maml:introduction>
          <maml:para>In this example, **PSReadLine** will respond to errors or conditions that require user attention.
The **BellStyle** is set to emit an audible beep at 1221 Hz for 60 ms.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Set-PSReadLineOption -BellStyle Audible -DingTone 1221 -DingDuration 60
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>&gt; [!NOTE]
&gt; This feature may not work in all hosts on platforms.</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 3: Set multiple options ---------</maml:title>
        <maml:introduction>
          <maml:para>`Set-PSReadLineOption` can set multiple options with a hash table.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
$PSReadLineOptions = @{
    EditMode = "Emacs"
    HistoryNoDuplicates = $true
    HistorySearchCursorMovesToEnd = $true
    Colors = @{
        "Command" = "#8181f7"
    }
}
Set-PSReadLineOption @PSReadLineOptions
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>The `$PSReadLineOptions` hash table sets the keys and values. `Set-PSReadLineOption` uses the keys
and values with `@PSReadLineOptions` to update the **PSReadLine** options.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>You can view the keys and values entering the hash table name, `$PSReadLineOptions` on the
PowerShell command line.</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 4: Set multiple color options ---------</maml:title>
        <maml:introduction>
          <maml:para>This example shows how to set more than one color value in a single command.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Set-PSReadLineOption -Colors @{
  Command            = 'Magenta'
  Number             = 'DarkGray'
  Member             = 'DarkGray'
  Operator           = 'DarkGray'
  Type               = 'DarkGray'
  Variable           = 'DarkGreen'
  Parameter          = 'DarkGreen'
  ContinuationPrompt = 'DarkGray'
  Default            = 'DarkGray'
}
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 5: Set color values for multiple types ---------</maml:title>
        <maml:introduction>
          <maml:para>This example shows three different methods for how to set the color of tokens displayed in
**PSReadLine**.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
Set-PSReadLineOption -Colors @{
 # Use a ConsoleColor enum
 "Error" = [ConsoleColor]::DarkRed</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para># 24 bit color escape sequence
 "String" = "$([char]0x1b)[38;5;100m"</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para># RGB value
 "Command" = "#8181f7"
}
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 6: Use ViModeChangeHandler to display Vi mode changes ---------</maml:title>
        <maml:introduction>
          <maml:para>This example emits a cursor change VT escape in response to a **Vi** mode change.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
function OnViModeChange {
    if ($args[0] -eq 'Command') {
        # Set the cursor to a blinking block.
        Write-Host -NoNewline "`e[1 q"
    } else {
        # Set the cursor to a blinking line.
        Write-Host -NoNewline "`e[5 q"
    }
}
Set-PSReadLineOption -ViModeIndicator Script -ViModeChangeHandler $Function:OnViModeChange
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>The **OnViModeChange** function sets the cursor options for the **Vi** modes: insert and command.
**ViModeChangeHandler** uses the `Function:` provider to reference **OnViModeChange** as a script
block object.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>For more information, see
[about_Providers](/powershell/module/microsoft.powershell.core/about/about_providers).</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 7: Use HistoryHandler to filter commands added to history ---------</maml:title>
        <maml:introduction>
          <maml:para>The following example shows how to use the `AddToHistoryHandler` to prevent saving any git commands
to history.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
$ScriptBlock = {
    param ([string]$Line)</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>if ($Line -match "^git") {
        return $false
    } else {
        return $true
    }
}</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>Set-PSReadLineOption -AddToHistoryHandler $ScriptBlock
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>The scriptblock returns `$false` if the command started with `git`. This has the same effect as
returning the `SkipAdding` **AddToHistory** enum. If the command doesn't start with `git`, the
handler returns `$true` and PSReadLine saves the command in history.</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 8: Use CommandValidationHandler to validate a command before its executed ---------</maml:title>
        <maml:introduction>
          <maml:para>This example shows how to use the **CommandValidationHandler** parameter to run a validate a command
before it's executed. The example specifically checks for the command `git` with the sub command
`cmt` and replaces that with the full name `commit`. This way you can create shorthand aliases for
subcommands.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
# Load the namespace so you can use the [CommandAst] object type
using namespace System.Management.Automation.Language</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>Set-PSReadLineOption -CommandValidationHandler {
    param([CommandAst]$CommandAst)</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>switch ($CommandAst.GetCommandName()) {
        'git' {
            $gitCmd = $CommandAst.CommandElements[1].Extent
            switch ($gitCmd.Text) {
                'cmt' {
                    [Microsoft.PowerShell.PSConsoleReadLine]::Replace(
                        $gitCmd.StartOffset, $gitCmd.EndOffset - $gitCmd.StartOffset, 'commit')
                }
            }
        }
    }
}
# This checks the validation script when you hit enter
Set-PSReadLineKeyHandler -Chord Enter -Function ValidateAndAcceptLine
```</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
      <command:example>
        <maml:title>--------- Example 9: Using the PromptText parameter ---------</maml:title>
        <maml:introduction>
          <maml:para>When there's a parse error, **PSReadLine** changes a part of the prompt red. The **PromptText**
parameter tells **PSReadLine** the part of the prompt string to make red.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>For example, the following example creates a prompt that contains the current path followed by the
greater-than character (`&gt;`) and a space.</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>```powershell
function prompt { "PS $PWD&gt; " }`
Set-PSReadLineOption -PromptText '&gt; ' # change the '&gt;' character red
Set-PSReadLineOption -PromptText '&gt; ', 'X ' # replace the '&gt;' character with a red 'X'
```</maml:para>
          <maml:para>&#x80;</maml:para>
          <maml:para>The first string is the portion of your prompt string that you want to make red when there is a
parse error. The second string is an alternate string to use for when there is a parse error.</maml:para>
        </maml:introduction>
        <dev:code />
        <dev:remarks />
      </command:example>
    </command:examples>
    <command:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Online Version</maml:linkText>
        <command:uri>https://learn.microsoft.com/powershell/module/psreadline/set-psreadlineoption?view=powershell-7.5&amp;WT.mc_id=ps-gethelp</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>about_PSReadLine</maml:linkText>
        <command:uri>./About/about_PSReadLine.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Get-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Get-PSReadLineOption</maml:linkText>
        <command:uri>Get-PSReadLineOption.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Remove-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Remove-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Set-PSReadLineKeyHandler</maml:linkText>
        <command:uri>Set-PSReadLineKeyHandler.md</command:uri>
      </maml:navigationLink>
    </command:relatedLinks>
  </command:command>
</helpItems>